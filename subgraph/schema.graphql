
# Protocol Contract
type ProtocolContract @entity {
  "Contract-Name"
  id: ID!

  "The contract"
  contract: Bytes!
}

#  Voucher Asset
type VoucherAsset @entity {
  "OwnerAddress-TokenId"
  id: ID!

  "Wallet"
  wallet: Bytes!

  "Token Id"
  tokenId: BigInt!
 
  "Value"
  value: BigInt!

  "Link to URI"
  uri: VoucherURI! 
 
  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

#  Voucher URI
type VoucherURI @entity {
  "TokenId"
  id: ID!

  "Token Id"
  tokenId: BigInt
 
  "URI"
  uri: String

  "Link to VoucherAsset"
  voucherAsset: VoucherAsset!
}

# Currency Whitelist
type CurrencyWhitelist @entity {
  "CurrencyAddress-Name"
  id: ID!

  "Currency Name"
  currencyName: String!

  "Currency Symbol"
  currencySymbol: String!

  "Currency Decimals"
  currencyDecimals: Int!

  "The currency contract"
  currency: Bytes!

  "Whether or not the currency should be whitelisted"
  whitelisted: Boolean!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type Account @entity {
  "The account's address"
  id: ID!

  "Link to profile"
  profile: Profile!

  "Link to creator details if this account is or ever was one"
  creator: Creator @derivedFrom(field: "account")

  "Link to SBT Asset"
  sbtAsset: SBTAsset @derivedFrom(field: "owner")

  "Link to dNFT collection"
  dnftCollection: DnftCollection @derivedFrom(field: "owner")

  "Link to Hub "
  hub: Hub @derivedFrom(field: "hubOwner")

  "Treasury On Received SBT Value history by this account"
  sbtValueReceivedHistories: [SBTValueReceivedHistory!]! @derivedFrom(field: "from")

  "SBT Approval Values granted by this account"
  sbtApprovalValues: [SBTApprovalValue!]! @derivedFrom(field: "owner")

  "SBT Approvals granted by this account"
  sbtAccountApprovals: [SBTAccountApproval!]! @derivedFrom(field: "owner")

  "All SBT Value transfers from this account to another"
  sbtTransferValueOut: [SBTTransferValueHistory!]! @derivedFrom(field: "from")

  "All SBT Value transfers to this account from another"
  sbtTransferValueIn: [SBTTransferValueHistory!]! @derivedFrom(field: "to")

  "All dNFTs currently owned by this account"
  dnfts: [DNFT!]! @derivedFrom(field: "owner")

  "All prepare publish history by this account"
  preparePublishFeesHistories: [PreparePublishFeesHistory!]! @derivedFrom(field: "publisher")

  "All distributed history by this account"
  distributeHistories: [DistributeHistory!]! @derivedFrom(field: "collector")

  "All Exchange ERC20 history by SBT Value by this account"
  exchangeERC20Histories: [ExchangeERC20BySBTHistory!]! @derivedFrom(field: "account")

  "All fee history that is genesis creator by this account"
  genesisCreatorFeeHistories: [DistributeHistory!]! @derivedFrom(field: "genesisCreator")

  "All fee history that is previous creator by this account"
  previousCreatorFeeHistories: [DistributeHistory!]! @derivedFrom(field: "previousCreator")

  "All airdroped dNFTs from  this account"
  dnftAirdropedHistories: [DnftAirdropedHistory!]! @derivedFrom(field: "from")

  "All dNFTs currently owner or listed by this account"
  nftsOwnedOrListed: [DNFT!]! @derivedFrom(field: "ownedOrListedBy")

  "All auctions created by this account"
  nftMarketAuctions: [DnftMarketAuction!]! @derivedFrom(field: "seller")

  "All bids placed by this account"
  nftBidsPlaced: [DnftMarketBid!]! @derivedFrom(field: "bidder")

  "All bids accepted by this account"
  nftBidsAccepted: [DnftMarketBid!]! @derivedFrom(field: "seller")

  "dNFT transfers from this account to another"
  nftTransfersOut: [DnftTransfer!]! @derivedFrom(field: "from")

  "dNFT transfers to this account from another"
  nftTransfersIn: [DnftTransfer!]! @derivedFrom(field: "to")

  "The total Value earned by this account, excluding any dNFTs minted by this creator"
  netRevenue: BigInt!

  "The total Value earned by this account but still pending finalization, excluding any dNFTs minted by this creator"
  netRevenuePending: BigInt!

  "Approvals granted by this account, note this does not include dnft.approvedSpender"
  dnftAccountApprovals: [DnftAccountApproval!]! @derivedFrom(field: "owner")

  "ApprovalValues granted by this account"
  dnftApprovalValues: [DnftApprovalValue!]! @derivedFrom(field: "owner")

  "dNFT actions initiated by this account"
  dnftHistories: [DnftHistory!]! @derivedFrom(field: "actorAccount")

  "All CurrencyEarnestFunds entries related to this account"
  currencyEarnestFunds: [CurrencyEarnestFunds!]! @derivedFrom(field: "user")

  "All offers made by this account"
  nftOffersMade: [DnftMarketOffer!]! @derivedFrom(field: "buyer")

  "All buy SBT by ETH histories that have occurred for this Account"
  buySBTByEthHistories: [BuySBTByEthHistory!] @derivedFrom(field: "account")  

  "All buy SBT by ERC20 histories that have occurred for this Account"
  buySBTByERC20Histories: [BuySBTByERC20History!] @derivedFrom(field: "account")  

}

# Profile record
type Profile @entity {
  "The wallet's address"
  id: ID!

  "The Soul Bound Token ID"
  soulBoundTokenId: BigInt!

  "The creator of profile in whitelisted set by system operator"
  creator: Bytes!

  "The wallet address of user"
  wallet: Bytes!

  "The nick name of user"
  nickName: String!

  "The image uri of user"
  imageURI: String!

  "The date/time the profile was initially created in seconds since Unix epoch"
  timestamp: BigInt!
}

# SoulBoundToken record
type SoulBoundToken @entity {
  "The Soul Bound Token Id"
  id: ID!
  
  "The wallet address of user"
  wallet: Bytes!
}

# SBT Token Asset
type SBTAsset @entity {
  "The wallet's address"
  id: ID!

  "The account which owned this SBT Id"
  owner: Account!

  "The balance amount associated with this SBT, in WEI"
  balance: BigInt!

  "An account authorized to transfer this SBT, if one was approved"
  approvedSpender: Account

  "All transfers that have occurred for this SBT"
  transfers: [SBTTransferHistory!] @derivedFrom(field: "sbtAsset")

  "All transferValues that have occurred for this SBT"
  transferValues: [SBTTransferValueHistory!] @derivedFrom(field: "sbtAsset")  

  "The date/time when the event occurred in seconds since Unix epoch"
  timestamp: BigInt!
}


# SBT Transfer history
type SBTTransferHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  sbtAsset: SBTAsset!

  "The account of from"
  from: Account!

  "The account of to"
  to: Account!

  "The tokenId for this specific SBT"
  tokenId: BigInt!

  "The date/time the transaction block was build in seconds since Unix epoch"
  timestamp: BigInt!
}

# SBT transfer value history    
type SBTTransferValueHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  sbtAsset: SBTAsset!

  "The account of from"
  from: Account!

  "The account of to"
  to: Account!

  "The value amount transferred"
  value: BigInt!

  "The date/time the transaction block was build in seconds since Unix epoch"
  timestamp: BigInt!
} 

# SBT Slot Changed history    
type SBTSlotChangedHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The account of user"
  account: Account!

  "The old slot"
  oldSlot: BigInt!

  "The new slot"
  newSlot: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}   

# SBT ApprovalForAll
type SBTAccountApproval @entity {
  "tokenAddress-owner-spender"
  id: ID!

  "The account which granted this approval"
  owner: Account!

  "The account which is authorized to transfer SBTs held by the owner"
  spender: Account!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}    

# SBT ApprovalValue 
type SBTApprovalValue @entity {
  "tokenAddress-soulBoundTokenId-spender"
  id: ID!
 
  "The Soul Bound Token Id"
  soulBoundTokenId: BigInt!
 
  "Owner of soulBoundTokenId"
  owner: Account!

  "The account which is authorized to transfer SBTs held by the owner"
  spender: Account!

  "The value of a token that a spender is allowed to manage"
  value: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}    

# Hub
type Hub @entity {
  "The hub creator's address"
  id: ID!

  "The account is owner of hub"
  hubOwner: Account!

  "Hub Id"
  hubId: BigInt!

  "All projects in this hub"
  projects: [Project!]! @derivedFrom(field: "hub")

  "The hub name"
  name: String!

  "The hub description"
  description: String!

  "The hub imageURI will be displayed"
  imageURI: String!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# publication for prepare data
type Publication @entity {
  "The Publication's id"
  id: ID!

  "The id of publication"
  publishId: BigInt!

  "The account of publisher"
  publisher: Account!

  "The hub of publication"
  hub: Hub!

  "The project of publication" 
  project: Project!

  "The sale price of publication while collector pay for" 
  salePrice: BigInt!

  "The royalty meassured in basis points"
  royaltyBasisPoints: Int!

  "The address od currency contract"
  currency: Bytes!

  "Amount of publication to mint"
  amount: BigInt!

  "Name of publication"
  name: String!

  "Description of publication"
  description: String!

  "Whether user can collect or not"
  canCollect: Boolean!

  "Material uris"
  materialURIs: [String!]

  "From tokens"
  fromTokenIds: [DNFT!]

  "The module for collect"
  collectModule: Bytes!

  "The init data for collect"
  collectModuleInitData: Bytes!

  "The publish module"
  publishModule: Bytes!

  "The init data for publish"
  publishModuleInitData: Bytes!

  "The genesis publish of publication"
  genesisPublish: Publish

  "The previous publish of publication"
  previousPublish: Publish
  
  "Amount of publish tax"
  publishTaxAmount: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

#  Project in Derivative dNFT contract
type Project @entity {
  "The project id"
  id: ID!

  "The id of project"
  projectId: BigInt!

  "dNFT contract"
  derivativeNFT: DerivativeNFTContract!

  "The account creator of project"
  projectCreator: Account!

  "The project In hub"
  hub: Hub!

  "Name of project"
  name: String!
  
  "Description of project"
  description:  String!
  
  "Image of project"
  image:  String
  
  "Metadata uri of project"
  metadataURI: String

  "Descriptor contract of project"     
  descriptor: Bytes

  transactionHash: Bytes

  "The default royalty in basis points"
  defaultRoyaltyBPS: Int!
  
  "User prePublish will permit by hub owner or not"
  permitByHubOwner: Boolean

  "All publications in this project"
  publications: [Publication!]! @derivedFrom(field: "project")
  
  "All publishes in this project"
  publishes: [Publish!]! @derivedFrom(field: "project")

  "All dNFT Token in this project"
  dnfts: [DNFT!]! @derivedFrom(field: "project")

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Publish Record
type Publish @entity {
  "publishId"
  id: ID!
 
  "The account of publisher"
  publisher: Account!

  "The prepare publication data"
  publication: Publication!

  "The publish In hub"
  hub: Hub!

  "In the project"
  project: Project!

  "dNFT contract"
  derivativeNFT: DerivativeNFTContract!

  "The dNFT this publish is for"
  dnft: DNFT!

  "The new dNFT tokenId after publish"
  newTokenId: BigInt!

  "The amount of initially published"
  amount: BigInt!

  "collect module init data"
  collectModuleInitData: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Treasury prepare publish fees history 
type PreparePublishFeesHistory @entity {
  "tx-logId-publishId"
  id: ID!
 
  "The account of publisher"
  publisher: Account!

  "Treasury account"
  treasury: Account!

  "Which publication"
  publication: Publication!

  "Fee amount of publish"
  feesAmountOfPublish: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Airdrop history
type DnftAirdropedHistory @entity {
  "tx-logId"
  id: ID!

  "The project"
  project: Project!
  
  "The publish"
  publish: Publish!

  "dNFT contract"
  derivativeNFT: DerivativeNFTContract!
  
  "The account of from"
  from: Account!

  "The token to airdroped"
  tokenId: BigInt!
  
  "List accounts of to"
  toAccounts: [BigInt!]!

  "List of values to airdroped"
  values: [BigInt!]!

  "List of new tokens"
  newTokenIds: [BigInt!]!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Bank Contract Receive Ether event
type DepositEtherHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The msg sender"
  sender: Bytes!

  "msg.value"
  amount: BigInt!

  "The receiver"
  receiver: Bytes!

  "Current balance of sender"
  balance: BigInt!

  "Additional data with no specified format"
  data: Bytes

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type Transaction @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The owner of transaction"
  owner: Bytes!

  "Index of Tx"
  txIndex: BigInt!

  "To"
  to: Bytes

  "Value"
  value: BigInt

  "Additional data with no specified format"
  data: Bytes

  "Whether is confirmed"
  isConfirmed: Boolean!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type ExecuteTransactionHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The owner of transaction"
  owner: Bytes!

  "Index of Tx"
  txIndex: BigInt!

  "To"
  to: Bytes!
  
  "Value"
  value: BigInt!
  
  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type VoucherDepositedHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The Soul Bound Token ID"
  soulBoundTokenId: BigInt!

  "Operator"
  operator: Bytes!

  "Voucher Token"
  tokenId: BigInt!
  
  "SBT Value"
  sbtValue: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type ExecuteTransactionERC3525History @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Owner"
  owner: Bytes!

  "Index of Tx"
  txIndex: BigInt!

  "From token"
  fromTokenId: BigInt!

  "To Token"
  toTokenId: BigInt!

  "SBT Value"
  value: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type VoucherRecord @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Creator"
  creator: Account!

  "Total Amount"
  totalAmount: BigInt!

  "To"
  to: [Bytes!]!

  "List of amount"
  amounts: [BigInt!]!

  "List of tokenIds"
  tokenIds: [BigInt!]!

  "Generated timestamp"
  generatedTimestamp: BigInt!
}

# ProfileCreator Whitelisted Record
type ProfileCreatorWhitelistedRecord @entity {
  "ProfileCreator-Address"
  id: ID!

  "Profile Creator"
  profileCreator: Bytes!

  "Whether in whitelist"
  whitelisted: Boolean!

  "Caller"
  caller: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# In FeeCollectModule when event Distribute is emitted
type DistributeHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Publish"
  publish: Publish!

  "Pay Value"
  payValue: BigInt!

  "Owner"
  owner: Account!

  "Collector"
  collector: Account!

  "Genesis Creator"
  genesisCreator: Account!

  "Previous Creator"
  previousCreator: Account!

  "Referrer"
  referrer: Account

  "Treasury Amount"
  treasuryAmount: BigInt!

  "Genesis Amount"
  genesisAmount: BigInt!

  "Previous Amount"
  previousAmount: BigInt!

  "Referrer Amount"
  referrerAmount: BigInt

  "Adjusted Amount"
  adjustedAmount: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Receiver history
type ReceiverReceivedHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Operator"
  operator: Bytes!

  "From token"
  fromTokenId: BigInt!

  "To Token"
  toTokenId: BigInt!

  "Value"
  value: BigInt!

  "Additional data with no specified format"
  data: Bytes

  "Gas"
  gas: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Dispatcher Set history
type Dispatcher @entity {
  "soulBoundTokenId"
  id: ID!

  "Account"
  account: Account!

  "Dispatcher"
  dispatcher: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# StateSet history
type StateSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Caller"
  caller: Bytes!

  "Previous state"
  prevState: Int!

  "New state"
  newState: Int!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Treasury SBT Value Received history - sbtvalueReceivedHistories
type SBTValueReceivedHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Sender"
  sender: Bytes!
  
  "Operator"
  operator: Bytes!
  
  "From"
  from: Account!
  
  "To"
  to: Account!

  "Value"
  value: BigInt!

  "Additional data with no specified format"
  data: Bytes!

  "Gas"
  gas: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Treasury earnest funds staked history
type DepositHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Account"
  account: Account!

  "Currency"
  currency: Bytes!

  "Amount"
  amount: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Manager contract EmergencyAdminSet history
type EmergencyAdminSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Caller"
  caller: Bytes!

  "Old emergency admin"
  oldEmergencyAdmin: Bytes!

  "New emergency admin"
  newEmergencyAdmin: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Manager contract ManagerGovernanceSet history
type ManagerGovernanceSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Caller"
  caller: Bytes!

  "Previous Governance"
  prevGovernance: Bytes!

  "New Governance"
  newGovernance: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals hub creator set whitelist 
type HubCreatorWhitelistedRecord  @entity {
  "soulBoundTokenId"
  id: ID!
  
  "The Soul Bound Token ID"
  soulBoundTokenId: BigInt!

  "Whitelisted"
  whitelisted: Boolean!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals Treasury Set history
type ModuleGlobalsTreasurySetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Previous treasury"
  prevTreasury: Bytes!

  "New treasury"
  newTreasury: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals Voucher Set history
type ModuleGlobalsVoucherSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Previous voucher"
  prevVoucher: Bytes!

  "New voucher"
  newVoucher: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type UserAmountLimitSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Previous UserAmountLimit"
  preUserAmountLimit: BigInt!

  "Current UserAmountLimit"
  userAmountLimit: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals Manager Set history
type ModuleGlobalsManagerSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Previous manager"
  prevManager: Bytes!

  "New manager"
  newManager: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals SBT Set history
type ModuleGlobalsSBTSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Previous SBT"
  prevSBT: Bytes!

  "New SBT"
  newSBT: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals Governance Set history
type ModuleGlobalsGovernanceSetHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Previous Governance"
  prevGovernance: Bytes!

  "New Governance"
  newGovernance: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}


# Treasury Fee Setting
type TreasuryFeeRecord @entity {
  "TreasuryFeeSetting"
  id: ID!

  "Previous TreasuryFee"
  prevTreasuryFee: Int!

  "New TreasuryFee"
  newTreasuryFee: Int!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# ModuleGlbals PublishRoyalty Set record
type PublishRoyaltyRecord @entity {
  "PublishRoyaltySetting"
  id: ID!

  "Previous Publish Royalty"
  prevPublishRoyalty: BigInt!

  "New Publish Royalty"
  newPublishRoyalty: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# CollectModule Whitelisted record
type CollectModuleWhitelistedRecord @entity {
  "collectModule-address"
  id: ID!

  "Collect Module"
  collectModule: Bytes!

  "Whitelisted"
  whitelisted: Boolean!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# PublishModule Whitelisted record
type PublishModuleWhitelistedRecord @entity {
  "publishModule-address"
  id: ID!

  "Publish Module"
  publishModule: Bytes!

  "Whitelisted"
  whitelisted: Boolean!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Template Whitelisted record
type TemplateWhitelistedRecord @entity {
  "template-address"
  id: ID!

  "Template"
  template: Bytes!

  "Whitelisted"
  whitelisted: Boolean!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Treasury Buy SBT By Eth history
type BuySBTByEthHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Account"
  account: Account!

  "Exchange Wallet"
  exchangeWallet: Bytes!

  "Ether Value"
  etherValue: BigInt!

  "SBT Value"
  sbtValue: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Treasury Buy SBT By ERC20  history
type BuySBTByERC20History @entity {
  "TransactionHash-logsIndex"
  id: ID!
  
  "Account"
  account: Account!

  "Exchange Wallet"
  exchangeWallet: Bytes!

  "Currency"
  currency: Bytes!

  "Amount of ERC20"
  amount: BigInt!

  "SBT Value"
  sbtValue: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}


# Price Set
type ExchangePrice @entity {
  "currency-address"
  id: ID!

  "Currency Name"
  currencyName: String!

  "Currency Symbol"
  currencySymbol: String!

  "Currency Decimals"
  currencyDecimals: Int!

  "Currency contract"
  currency: Bytes!

  "Currency Amount"
  currencyAmount: BigInt!

  "SBT Amount"
  sbtAmount: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type ExchangeERC20BySBTHistory  @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Account"
  account : Account!

  "Currency ERC20 contract"
  currency: Bytes!
  
  "ERC20 Amount"
  amount: BigInt!

  "SBT Amount"
  sbtAmount: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!

}

# Market Place
type Market @entity {
  "DerivativeNFT-Address"
  id: ID!
  
  "dNFT contract"
  derivativeNFT: DerivativeNFTContract!

  "The project of publication"
  project: Project! 

  "Fee Pay Type"
  feePayType: Int!

  "Fee Share Type"
  feeShareType: Int!

  "Royalty Basis Points"
  royaltyBasisPoints: Int!

  "Collect Module"
  collectModule: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type MarketPlaceERC3525ReceivedHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Sender"
  sender: Bytes!

  "Operator"
  operator: Bytes!

  "From token"
  fromTokenId: BigInt!

  "To Token"
  toTokenId: BigInt!
  
  "Value"
  value: BigInt!

  "Additional data with no specified format"
  data: Bytes!

  "Gas"
  gas: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

type Creator @entity {
  "The account's address"
  id: ID!

  "The creator's account information"
  account: Account!

  "All dNFTs minted by this creator"
  dnfts: [DNFT!]! @derivedFrom(field: "creator")

  "The total Value for sales of dNFTs this creator minted"
  netSales: BigInt!

  "The total Value for sales of dNFTs this creator minted but still pending finalization"
  netSalesPending: BigInt!

  "The total Value earned by this creator"
  netRevenue: BigInt!

  "The total Value earned by this creator but still pending finalization"
  netRevenuePending: BigInt!
}

type DerivativeNFTContract @entity {
  "The contract's address"
  id: ID!

  "The contract address"
  contract: Bytes!

  "The token name"
  name: String

  "The token symbol"
  symbol: String

  "Append baseURI+tokenIPFSPath to get the tokenURI"
  baseURI: String

  "Max tokenId for the collection, if applicable"
  maxTokenID: BigInt

  "All dNFTs minted by this contract"
  dnfts: [DNFT!]! @derivedFrom(field: "derivativeNFT")
}

type DnftMarketContract @entity {
  "The contract's address"
  id: ID!

  "How many bids have been placed for any auction on Foundation"
  numberOfBidsPlaced: BigInt!
}

enum DnftMarketAuctionStatus {
  "This auction has not been canceled or finalized yet, it may be active or pending finalization"
  Open

  "This auction was canceled before the reserve price was hit"
  Canceled

  "This auction was finalized and the dNFT has been transferred to the winner"
  Finalized

  "This auction was invalidated due to another action such as Buy Now"
  Invalidated
}

type DnftMarketAuction @entity {
  "marketContractAddress-auctionId"
  id: ID!

  "The contract managing this auction"
  dnftMarketContract: DnftMarketContract!

  "The id for this auction"
  auctionId: BigInt!

  "The dNFT being sold in this auction"
  dnft: DNFT!

  "The dNFT contract for this dNFT"
  derivativeNFT: DerivativeNFTContract!

  "The project for this dNFT"
  project: Project!

  "The current status of this auction"
  status: DnftMarketAuctionStatus!

  "The dNFT owner currently offering the dNFT for sale"
  seller: Account!

  "The date/time the auction was initially created in seconds since Unix epoch"
  dateCreated: BigInt!

  "The tx hash where this auction was initially created"
  transactionHashCreated: Bytes!

  "The date/time the auction countdown began, only known once reserve price has been met in seconds since Unix epoch"
  dateStarted: BigInt

  "The date/time the auction will be closed, only known once the reserve price has been met in seconds since Unix epoch"
  dateEnding: BigInt

  "The date/time the auction was canceled in seconds since Unix epoch, if applicable"
  dateCanceled: BigInt

  "The reason this auction was canceled, if known"
  canceledReason: String

  "The date/time the auction was finalized in seconds since Unix epoch, if applicable"
  dateFinalized: BigInt

  "The tx hash where this auction was canceled, if applicable"
  transactionHashCanceled: Bytes
  
  "The ERC20 currency contract"
  currency: Bytes!

  "The initial reserve price which needs to be met in order to begin the auction countdown"
  reservePrice: BigInt!

  "The first bid which met the reserve price"
  initialBid: DnftMarketBid

  "The current highest bid, if one has been placed"
  highestBid: DnftMarketBid

  "All bids placed in this auction"
  bids: [DnftMarketBid!]! @derivedFrom(field: "dnftMarketAuction")

  "How much the creator earned from this auction, set once there a bid is placed"
  creatorRevenue: BigInt

  "How much the previous creator earned from this auction, set once there a bid is placed"
  previousCreatorRevenue: BigInt

  "How much Foundation earned from this auction, set once there a bid is placed"
  foundationRevenue: BigInt

  "How much the owner (if not the creator) earned from this auction, set once there a bid is placed"
  ownerRevenue: BigInt

  "How long the auction runs for once the reserve price has been met in seconds"
  duration: BigInt!

  "How long to extend the dateEnding if a bid is placed near the end of the countdown in seconds"
  extensionDuration: BigInt!

  "True if this is the first sale on Foundation and being sold by the creator"
  isPrimarySale: Boolean!

  "How many bids have been placed for any auction on Foundation"
  numberOfBids: BigInt!

  "The volume of Value bid"
  bidVolume: BigInt!

  "The date/time the auction was invalidated in seconds since Unix epoch, if applicable"
  dateInvalidated: BigInt

  "The tx hash where this auction was invalidated, if applicable"
  transactionHashInvalidated: Bytes

  "Referrer address for the winner bid, if applicable"
  buyReferrer: Account

  "Referral fee paid for the winner bid, if applicable"
  buyReferrerFee: BigInt

  "Referral fee paid for the winner bid from owner fee, if applicable"
  buyReferrerSellerFee: BigInt

  "How much Foundation earned from this auction"
  foundationProtocolFee: BigInt
}

enum DnftMarketBidStatus {
  "This bid is currently the highest, either on-track to win or has won and is pending finalization"
  Highest

  "This bid was outbid by another user"
  Outbid

  "This bid won the auction and was finalized, completing the dNFT transfer"
  FinalizedWinner
}

type DnftMarketBid @entity {
  "marketContractAddress-auctionId-txHash-logId"
  id: ID!

  "The auction this bid was for"
  dnftMarketAuction: DnftMarketAuction!

  "The dNFT being sold in this auction"
  dnft: DNFT!

  "The account which placed the bid"
  bidder: Account!

  "The date/time the bid was placed in seconds since Unix epoch"
  datePlaced: BigInt!

  "The tx hash that placed the bid"
  transactionHashPlaced: Bytes!

  "The size of the bid placed, including fees"
  amount: BigInt!

  "The current status of this bid"
  status: DnftMarketBidStatus!

  "The date/item when this bid became no longer Active in seconds since Unix epoch, if applicable"
  dateLeftActiveStatus: BigInt

  "The tx hash that moved this bid out of Active status, if applicable"
  transactionHashLeftActiveStatus: Bytes

  "The account which offered this dNFT for sale"
  seller: Account!

  "True if this bid caused the end time of an auction to be extended"
  extendedAuction: Boolean!

  "The bid which outbid this one, if applicable"
  outbidByBid: DnftMarketBid

  "The bid this one outbid, if applicable"
  bidThisOutbid: DnftMarketBid
}

enum Marketplace {
  "Foundation's market contract is the only one supported ATM but more will be added in the future"
  Foundation
}

enum HistoricalEvent {
  "The original mint event for this dNFT"
  Minted

  "The dNFT has been listed for sale"
  Listed

  "The dNFT was unlisted from the market"
  Unlisted

  "The price for this listing has been modified"
  PriceChanged

  "A bid for the dNFT has been made"
  Bid

  "The dNFT has been sold, this status is not reflected until the auction has been settled"
  Sold

  "The sale has been settled on-chain and the dNFT was transferred to the new owner"
  Settled

  "The dNFT was transferred from one address to another"
  Transferred

  "The dNFT value was transferred from one tokenId to another tokenId"
  ValueTransferred

  "The dNFT was burned and now no longer available on-chain"
  Burned

  "The dNFT value was burned"
  ValueBurned

  "The creator has been migrated to a new account"
  CreatorMigrated

  "The current owner of this dNFT has migrated to a new account"
  OwnerMigrated

  "The seller for the current auction has migrated to a new account"
  SellerMigrated

  "The payment address for this dNFT has migrated to a new address"
  CreatorPaymentAddressMigrated

  "The auction was invalidated due to another action such as Buy Now"
  AuctionInvalidated

  "The dNFT received an offer"
  OfferMade

  "The latest offer for an dNFT was increased"
  OfferChanged

  "The offer for this dNFT expired before it was expired, this status is not reflected until another action is performed"
  OfferExpired

  "The offer for this dNFT was accepted"
  OfferAccepted

  "The offer for this dNFT is no longer valid due to another action such as Buy Now"
  OfferInvalidated

  "The offer for this dNFT was canceled"
  OfferCanceled

  "The dNFT had a buy now price set"
  BuyPriceSet

  "The buy now for this dNFT was accepted"
  BuyPriceAccepted

  "The buy now for this dNFT is no longer valid due to another action such as auction kick off"
  BuyPriceInvalidated

  "The buy now for this dNFT was canceled"
  BuyPriceCanceled
}

type DnftHistory @entity {
  "tx-logId-eventType"
  id: ID!

  "The dNFT being sold in this auction"
  dnft: DNFT!

  "The type of action that this row represents"
  event: HistoricalEvent!

  "The related auction for this change, if applicable"
  auction: DnftMarketAuction

  "The related offer for this change, if applicable"
  offer: DnftMarketOffer

  "The related buy now for this change, if applicable"
  buyNow: DnftMarketBuyNow

  "The contract which processed this event, may be a marketplace or the dNFT itself"
  contractAddress: Bytes!

  "The date/time of this event in seconds since Unix epoch"
  date: BigInt!

  "Which market which facilitated this transaction, null when the action was specific to the dNFT itself"
  marketplace: Marketplace

  "The transaction hash where this event occurred"
  transactionHash: Bytes!

  "The account associated with this event, if unknown the txOrigin is used. Usually the same as txOrigin but may differ when multisig or other contracts are used"
  actorAccount: Account!

  "The msg.sender for the transaction associated with this event"
  txOrigin: Account!

  "The destination of the dNFT for events where the dNFT was transferred, null if n/a"
  nftRecipient: Account

  "The value amount associated with this event, in Value. Null if unknown or n/a"
  amount: BigInt

  "The ERC-20 value associated with this event. Null if unknown or Value was used"
  amountInTokens: BigInt

  "The ERC-20 token address associated with this event. Null if unknown or Value was used"
  tokenAddress: Bytes
}

# TODO
type PercentSplitShare @entity {
  "contractAddress-logId"
  id: ID!

  "The split this share is for"
  split: PercentSplit!

  "The recipient included in the split"
  account: Account!

  "The percent share this recipient will receive"
  shareInPercent: BigDecimal!

  "The index position of this share in the split, as defined in the contract"
  indexOfShare: BigInt!
}

# LEVEL_FIVE only
type PercentSplit @entity {
  "The address of this split contract"
  id: ID!

  "The recipients and their percent share for this split"
  shares: [PercentSplitShare!]! @derivedFrom(field: "split")

  "All the dNFTs currently leveraging this split"
  dnfts: [DNFT!]! @derivedFrom(field: "percentSplit")

  "How many different shares are in this split"
  shareCount: BigInt!

  "The date/time this split was initially created in seconds since Unix epoch"
  dateCreated: BigInt!
}

type CurrencyEarnestFunds @entity {
  "currency-userAddress"
  id: ID!

  "The currency contract"
  currency: Bytes!

  "User"
  user: Account!

  "Balance"
  balance: BigInt!

  "All Earnest Funds Escrow"
  escrows: [CurrencyEarnestFundsEscrow!]! @derivedFrom(field: "currencyEarnestFunds")

  "The date/item when escrows updated in seconds since Unix epoch"
  dateLastUpdated: BigInt!
}

type CurrencyEarnestFundsEscrow @entity {
  "userAddress-dateExpiry"
  id: ID!

  "Currency Earnest Funds"
  currencyEarnestFunds: CurrencyEarnestFunds!

  "Amount of escrow"
  amount: BigInt!

   "The date/item when escrows expiry in seconds since Unix epoch"
  dateExpiry: BigInt!

  "Transaction Hash when escrow created"
  transactionHashCreated: Bytes!

  "Transaction Hash when escrow removed"
  transactionHashRemoved: Bytes

  "The date/item when escrows removed in seconds since Unix epoch"
  dateRemoved: BigInt
}

enum DnftMarketOfferStatus {
  "This offer is applicable unless it has expired"
  Open

  "This offer has been outbid by another offer, potentially from the same buyer"
  Outbid

  "This offer has expired, this status is not reflected until another action is performed"
  Expired
  
  "This offer has been canceled"
  Canceled

  "This offer was accepted"
  Accepted

  "This offer is no longer valid due to another action such as Buy Now"
  Invalidated
}

type DnftMarketOffer @entity {
  "tx-logId"
  id: ID!

  "The contract managing this offer"
  dnftMarketContract: DnftMarketContract!

  "The dNFT this offer is for"
  dnft: DNFT!

  "The dNFT contract for this dNFT"
  derivativeNFT: DerivativeNFTContract!

  "The current status of this offer"
  status: DnftMarketOfferStatus!

  "The account making this offer"
  buyer: Account!

  "The seller which accepted this offer, if applicable"
  seller: Account

  "The currency contract address"
  currency: Bytes!

  "The value being offered for this dNFT"
  amount: BigInt!

  "The date/time the offer was initially created in seconds since Unix epoch"
  dateCreated: BigInt!

  "The tx hash where this offer was initially created"
  transactionHashCreated: Bytes!

  "The date/time the offer will expire in seconds since Unix epoch"
  dateExpires: BigInt!

  "The date/time the offer was canceled in seconds since Unix epoch, if applicable"
  dateCanceled: BigInt

  "The reason this offer was canceled, if known"
  canceledReason: String

  "The tx hash where this offer was canceled, if applicable"
  transactionHashCanceled: Bytes

  "The date/time the offer was accepted in seconds since Unix epoch, if applicable"
  dateAccepted: BigInt

  "The tx hash where this offer was accepted, if applicable"
  transactionHashAccepted: Bytes

  "The date/time the offer was outbid in seconds since Unix epoch, if applicable"
  dateOutbid: BigInt

  "The tx hash where this offer was outbid, if applicable"
  transactionHashOutbid: Bytes

  "The date/time the offer was invalidate in seconds since Unix epoch, if applicable"
  dateInvalidated: BigInt

  "The tx hash where this offer was outbid, if applicable"
  transactionHashInvalidated: Bytes

  "How much the creator earned from this offer, set once accepted"
  creatorRevenue: BigInt

  "How much the previous creator earned from this auction, set once there a bid is placed"
  previousCreatorRevenue: BigInt

  "How much Protocol earned from this offer, set once accepted"
  foundationRevenue: BigInt

  "How much the owner (if not the creator) earned from this offer, set once accepted"
  ownerRevenue: BigInt

  "True if this is the first sale on Foundation and being sold by the creator, not known until the offer is accepted"
  isPrimarySale: Boolean

  "The offer that was outbid when this offer was placed, if applicable"
  outbidOffer: DnftMarketOffer

  "The offer that outbid this offer, if applicable"
  offerOutbidBy: DnftMarketOffer

  "Referrer address for the accepted offer, if applicable"
  buyReferrer: Account

  "Referral fee paid for the accepted offer, if applicable"
  buyReferrerFee: BigInt

  "Referral fee paid for the accepted offer from owner fee, if applicable"
  buyReferrerSellerFee: BigInt

  "How much Foundation earned from this offer, set once accepted"
  foundationProtocolFee: BigInt
}

enum DnftMarketBuyNowStatus {
  "This buy now is applicable"
  Open

  "This buy now has been canceled"
  Canceled

  "This buy now was accepted"
  Accepted

  "This buy now is no longer valid due to another action such as accepted offer / kicked off auction"
  Invalidated
}

type DnftMarketBuyNow @entity {
  "tx-logId"
  id: ID!

  "The contract managing this buy now"
  dnftMarketContract: DnftMarketContract!

  "The dNFT this buy now is for"
  dnft: DNFT!

  "The dNFT contract for this dNFT"
  derivativeNFT: DerivativeNFTContract!

  "The Project of this buy now if for"
  project: Project!

  "The current status of this buy now"
  status: DnftMarketBuyNowStatus!

  "The seller which owns the dNFT."
  seller: Account!

  "The currency of buy price"
  currency: Bytes!

  "The sale price of this dNFT"
  salePrice: BigInt!

  "The dNFT token id"
  tokenId: BigInt!

  "The units put on sell for this dNFT"
  units: BigInt!

  "The date/time the buy now was initially created in seconds since Unix epoch"
  dateCreated: BigInt!

  "The tx hash where this buy now was initially created"
  transactionHashCreated: Bytes!

  "The dnft recipient, if applicable"
  buyer: Account

  "The date/time the buy now was canceled in seconds since Unix epoch, if applicable"
  dateCanceled: BigInt

  "The tx hash where this buy now was canceled, if applicable"
  transactionHashCanceled: Bytes

  "The date/time the buy now was accepted in seconds since Unix epoch, if applicable"
  dateAccepted: BigInt

  "The tx hash where this buy now was accepted, if applicable"
  transactionHashAccepted: Bytes

  "The date/time the buy now was invalidate in seconds since Unix epoch, if applicable"
  dateInvalidated: BigInt

  "The tx hash where this offer was outbid, if applicable"
  transactionHashInvalidated: Bytes

  "How much the creator earned from this buy now, set once accepted"
  creatorRevenue: BigInt

  "How much the previous creator earned from this auction, set once there a bid is placed"
  previousCreatorRevenue: BigInt

  "How much Protocol earned from this buy now, set once accepted"
  foundationRevenue: BigInt

  "How much the owner (if not the creator) earned from this buy now, set once accepted"
  ownerRevenue: BigInt

  "True if this is the first sale on Foundation and being sold by the creator, not known until the offer is accepted"
  isPrimarySale: Boolean

  "Referrer address for the buy, if applicable"
  buyReferrer: Account

  "Referral fee paid for the buy, if applicable"
  buyReferrerFee: BigInt

  "Referral fee paid for the buy from owner fee, if applicable"
  buyReferrerSellerFee: BigInt

  "How much Foundation earned from this buy now, set once accepted"
  foundationProtocolFee: BigInt
}

### DNFT ###

type DNFT @entity {
  "tokenContractAddress-tokenId"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  "The tokenId for this specific dNFT"
  tokenId: BigInt!

  "The project of this dNFT"
  project: Project!

  "The publish of this dNFT"
  publish: Publish!
 
  "Link to dNFT ImageURI"
  imageURI: DnftImageURI

  "The content path for the metadata of this dNFT on IPFS"
  tokenIPFSPath: String

  "The creator of this dNFT"
  creator: Creator

  "The genesis publish of this dNFT"
  genesisPublish: Publish

  "The previous publish of this dNFT"
  previousPublish: Publish

  "The basisPoint royalty"
  royaltyBasisPoints: Int

  "The date/time when this dNFT was minted in seconds since Unix epoch"
  dateMinted: BigInt!

  "The transfer details where this dNFT was minted"
  mintedTransfer: DnftTransfer @derivedFrom(field: "dnft")

  "The current owner of this dNFT"
  owner: Account!

  "The current owner or the owner who listed the dNFT"
  ownedOrListedBy: Account!

  "An account authorized to transfer this dNFT, if one was approved"
  approvedSpender: Account

  "All dNFT collection that have collected for this dNFT"
  dnftCollections: [DnftCollection!] @derivedFrom(field: "dnft")

  "All transfers that have occurred for this dNFT"
  transfers: [DnftTransfer!] @derivedFrom(field: "dnft")

  "All transferValues that have occurred for this dNFT"
  transferValues: [DnftTransferValue!] @derivedFrom(field: "dnft")

  "All bids ever placed for this dNFT"
  bids: [DnftMarketBid!]! @derivedFrom(field: "dnft")

  "All history ever collected for this dNFT"
  collectedHistories: [DnftCollectedHistory!]! @derivedFrom(field: "dnft")

  "The total Value for sales of this dNFT"
  netSales: BigInt!

  "The total Value for sales of this dNFT but still pending finalization"
  netSalesPending: BigInt!

  "The total Value earned by the creator from this dNFT"
  netRevenue: BigInt!

  "The total Value earned by this creator from this dNFT but still pending finalization"
  netRevenuePending: BigInt!

  "True if the dNFT has not yet been sold in the Foundation market"
  isFirstSale: Boolean!

  "All auctions which were created for this dNFT"
  auctions: [DnftMarketAuction!]! @derivedFrom(field: "dnft")

  "The current or last previous auction for this dNFT"
  mostRecentAuction: DnftMarketAuction

  "The current or last auction for this dNFT which has not been canceled, if any"
  mostRecentActiveAuction: DnftMarketAuction

  "The last auction for this dNFT which was finalized, if there was one"
  latestFinalizedAuction: DnftMarketAuction

  "The event history for this dNFT"
  dnftHistory: [DnftHistory!]! @derivedFrom(field: "dnft")

  "An optional address to receive revenue and creator royalty payments generated by this dNFT"
  tokenCreatorPaymentAddress: Bytes

  "A reference to the split details defined by the tokenCreatorPaymentAddress, if that address is a PercentSplit"
  percentSplit: PercentSplit

  "The most recent sale price in the Foundation marketplace, if there has been one"
  lastSalePrice: BigInt

  "All offers made for this dNFT"
  nftOffers: [DnftMarketOffer!]! @derivedFrom(field: "dnft")

  "The most recent offer made for this dNFT, which may or may not still be valid"
  mostRecentOffer: DnftMarketOffer

  "The most recent buy now for this dNFT, which may or may not still be valid"
  mostRecentBuyNow: DnftMarketBuyNow

  "All buy nows made for this dNFT"
  nftBuyNows: [DnftMarketBuyNow!]! @derivedFrom(field: "dnft")
}

type DnftTransfer @entity {
  "tx-logId"
  id: ID!

  "The DNFT which was transferred"
  dnft: DNFT!

  "The source of the transfer, 0 when the token was minted"
  from: Account!

  "The destination of the transfer, 0 when the token is burned"
  to: Account!
  
  "Token"
  tokenId: BigInt!

  "The date/time of the transfer in seconds since Unix epoch"
  dateTransferred: BigInt!

  "The tx hash where the transfer occurred"
  transactionHash: Bytes!

}

# DNFT Collected history
type DnftCollectedHistory @entity {
  "tokenContractAddress-projectId-tokenId"
  id: ID!

  "Project"
  project: Project!

  "DerivativeNFT contract address"
  derivativeNFT: DerivativeNFTContract!

  "The dNFT this publish is for"
  dnft: DNFT!

  "From"
  from: Account!

  "To"
  to: Account!

  "Token"
  tokenId: BigInt!

  "The units collected"
  units: BigInt!

  "New Token"
  newTokenId: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

#  DNFT collection
type DnftCollection @entity {
  "tokenContractAddress-tokenId"
  id: ID!

  "The DNFT for this token"
  dnft: DNFT!

  "The current owner of this dNFT"
  owner: Account!

  "Token"
  tokenId: BigInt!

  "Value"
  value: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}


#  DNFT transfer value history    
type DnftTransferValue @entity {
  "tokenAddress-fromTokenId-toTokenId"
  id: ID!

  "The DNFT which was transferred"
  dnft: DNFT!

  "From"
  from: Account!

  "To"
  to: Account!

  "Value"
  value: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
} 

#  DNFT Slot Changed history    
type DnftSlotChanged @entity {
  "tokenAddress-tokenId-oldSlot"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  tokenId: BigInt!

  oldSlot: BigInt!

  newSlot: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
} 

# DNFT burn history    
type DnftBurn @entity {
  "tokenAddress-tokenId"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  project: Project!

  tokenId: BigInt!

  owner: Account!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}    


# DNFT account ApprovalForAll 
type DnftAccountApproval @entity {
  "tokenAddress-owner-spender"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  "The account which granted this approval"
  owner: Account!

  "The account which is authorized to transfer dNFTs held by the owner"
  spender: Account!
}

# DNFT ApprovalValue 
type DnftApprovalValue @entity {
  "tokenAddress-owner-spender"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  "The account which granted this approval"
  owner: Account!

  tokenId: BigInt!

  operator: Account!

  value: BigInt!
  
  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}    

#  DNFT image uri  
type DnftImageURI @entity {
  "tokenAddress-tokenId"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  tokenId: BigInt!

  imageURI: String!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

#  TransactionHash done history
type TransactionHashHistory @entity {
  "TransactionHash"
  id: ID!

  "Event Name"
  eventName: String!

  "Event Address"
  eventAddress: Bytes!

  "Log Index"
  logIndex: BigInt!

  "The date/time any event emit in seconds since Unix epoch"
  timestamp: BigInt!
}


