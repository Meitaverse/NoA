
type Account @entity {
  "The account's address"
  id: ID!

  "Link to profile"
  profile: Profile!

  #"Link to creator details if this account is or ever was one"
  creator: Creator @derivedFrom(field: "account")

  "Link to SBT Asset"
  sbtAsset: SBTAsset @derivedFrom(field: "owner")

  "Link to dNFT collection"
  dnftCollection: DnftCollection @derivedFrom(field: "owner")

  "Link to Hub "
  hub: Hub @derivedFrom(field: "hubOwner")

  "Deposit history to bank treasury by this account"
  deposits: [ERC3525ReceivedHistory!]! @derivedFrom(field: "from")

  "All Voucher mint history by this account"
  voucherMintHistories: [NFTVoucherHistory!]! @derivedFrom(field: "account")

  "SBT Approval Values granted by this account"
  sbtApprovalValues: [SBTApprovalValue!]! @derivedFrom(field: "owner")

  "SBT Approvals granted by this account"
  sbtAccountApprovals: [SBTAccountApproval!]! @derivedFrom(field: "owner")

  "All SBT Value transfers from this account to another"
  sbtTransferValueOut: [SBTTransferValueHistory!]! @derivedFrom(field: "from")

  "All SBT Value transfers to this account from another"
  sbtTransferValueIn: [SBTTransferValueHistory!]! @derivedFrom(field: "to")

  "All dNFTs currently owned by this account"
  nfts: [DNFT!]! @derivedFrom(field: "owner")

  "All collected history by this account"
  collectHistories: [FeesForCollectHistory!]! @derivedFrom(field: "collector")

  "All fee history that is genesis creator by this account"
  genesisCreatorFeeHistories: [FeesForCollectHistory!]! @derivedFrom(field: "genesisCreator")

  "All fee history that is previous creator by this account"
  previousCreatorFeeHistories: [FeesForCollectHistory!]! @derivedFrom(field: "previousCreator")

  "All airdroped dNFTs from  this account"
  dnftAirdropedHistories: [DnftAirdropedHistory!]! @derivedFrom(field: "from")

  "All dNFTs currently owner or listed by this account"
  nftsOwnedOrListed: [DNFT!]! @derivedFrom(field: "ownedOrListedBy")

  "All auctions created by this account"
  nftMarketAuctions: [DnftMarketAuction!]! @derivedFrom(field: "seller")

  "All bids placed by this account"
  nftBidsPlaced: [DnftMarketBid!]! @derivedFrom(field: "bidder")

  "All bids accepted by this account"
  nftBidsAccepted: [DnftMarketBid!]! @derivedFrom(field: "seller")

  "dNFT transfers from this account to another"
  nftTransfersOut: [DnftTransfer!]! @derivedFrom(field: "from")

  "dNFT transfers to this account from another"
  nftTransfersIn: [DnftTransfer!]! @derivedFrom(field: "to")

  "The total SBTValue earned by this account, excluding any dNFTs minted by this creator"
  netRevenueInSBTValue: BigDecimal!

  "The total SBTValue earned by this account but still pending finalization, excluding any dNFTs minted by this creator"
  netRevenuePendingInSBTValue: BigDecimal!

  "Approvals granted by this account, note this does not include dnft.approvedSpender"
  dnftAccountApprovals: [DnftAccountApproval!]! @derivedFrom(field: "owner")

  "ApprovalValues granted by this account"
  dnftApprovalValues: [DnftApprovalValue!]! @derivedFrom(field: "owner")

  "dNFT actions initiated by this account"
  dnftHistory: [DnftHistory!]! @derivedFrom(field: "actorAccount")

  "All Fsbt entries related to this account."
  fsbt: [Fsbt!]! @derivedFrom(field: "user")

  "All offers made by this account"
  nftOffersMade: [DnftMarketOffer!]! @derivedFrom(field: "buyer")

}

# Profile record
type Profile @entity {
  "The wallet's address"
  id: ID!

  "The Soul Bound Token ID"
  soulBoundTokenId: BigInt!

  "The creator of profile in whitelisted set by system operator"
  creator: Bytes!

  "The wallet address of user"
  wallet: Bytes!

  "The nick name of user"
  nickName: String!

  "The image uri of user"
  imageURI: String!

  "The date/time the profile was initially created in seconds since Unix epoch"
  timestamp: BigInt!
}

# SoulBoundToken record
type SoulBoundToken @entity {
  "The Soul Bound Token Id"
  id: ID!
  
  "The wallet address of user"
  wallet: Bytes!
}

# SBT Token Asset
type SBTAsset @entity {
  "The wallet's address"
  id: ID!

  "The account which owned this SBT Id"
  owner: Account!

  "The balance amount associated with this SBT, in WEI"
  balance: BigInt!

  "An account authorized to transfer this SBT, if one was approved"
  approvedSpender: Account

  "The date/time when the event occurred in seconds since Unix epoch"
  timestamp: BigInt!
}


# SBT Transfer history
type SBTTransferHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The account of from"
  from: Account!

  "The account of to"
  to: Account!

  "The tokenId for this specific SBT"
  tokenId: BigInt!

  "The date/time the transaction block was build in seconds since Unix epoch"
  timestamp: BigInt!
}

# SBT transfer value history    
type SBTTransferValueHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The account of from"
  from: Account!

  "The account of to"
  to: Account!

  "The value amount transferred"
  value: BigInt!

  "The date/time the transaction block was build in seconds since Unix epoch"
  timestamp: BigInt!
} 

# SBT Slot Changed history    
type SBTSlotChangedHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "The account of user"
  account: Account!

  "The old slot"
  oldSlot: BigInt!

  "The new slot"
  newSlot: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
} 

# Mint SBTValue history    
type MintSBTValueHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Caller address"
  caller: Bytes!

  "The account minted to"
  account: Account!

  "The value amount minted"
  value: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
} 
    
# Burn SBT history    
type BurnSBTHistory @entity {
  "TransactionHash-logsIndex"
  id: ID!

  "Caller address"
  caller: Bytes!

  "The account to be burned"
  account: Account!

  "The balance amount of SBT value and will be transfer to bank treasury"
  balance: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}    
  
# SBT ApprovalForAll
type SBTAccountApproval @entity {
  "tokenAddress-owner-spender"
  id: ID!

  "The account which granted this approval"
  owner: Account!

  "The account which is authorized to transfer SBTs held by the owner"
  spender: Account!
}    

# SBT ApprovalValue 
type SBTApprovalValue @entity {
  "tokenAddress-soulBoundTokenId-spender"
  id: ID!
 
  "The Soul Bound Token Id"
  soulBoundTokenId: BigInt!
 
  "Owner of "
  owner: Account!

  "The account which is authorized to transfer SBTs held by the owner"
  spender: Account!

  "The value of a token that a spender is allowed to manage."
  value: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}    

# Hub
type Hub @entity {
  "The hub creator's address"
  id: ID!

  "The account is owner of hub"
  hubOwner: Account!

  "Hub Id"
  hubId: BigInt!

  "All projects in this hub"
  projects: [Project!]!@derivedFrom(field: "hub")

  "The hub name"
  name: String!

  "The hub description"
  description: String!

  "The hub imageURI will display in web"
  imageURI: String!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# publication for prepare data
type Publication @entity {
  "The Publication's id"
  id: ID!

  publishId: BigInt!

  publisher: Account!

  hub: Hub!

  project: Project!

  salePrice: BigInt!

  royaltyBasisPoints: BigInt!

  amount: BigInt!

  name: String!

  description: String!

  canCollect: Boolean!

  materialURIs: [String!]!

  fromTokenIds: [BigInt!]!

  collectModule: Bytes!

  collectModuleInitData: Bytes!

  publishModule: Bytes!

  publishModuleInitData: Bytes!

  genesisPublishId: BigInt!

  previousPublishId: BigInt!
  
  publishTaxAmount: BigInt!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

#  Project in Derivative dNFT contract
type Project @entity {
  "The project id"
  id: ID!

  projectId: BigInt!

  "dNFT contract"
  derivativeNFT: DerivativeNFTContract!

  "The account creator of project"
  projectCreator: Account!

  "The project In hub"
  hub: Hub!

  "All publications in this project"
  publications: [Publication!]! @derivedFrom(field: "project")
  
  "All publishes in this project"
  publishes: [Publish!]! @derivedFrom(field: "project")

  "All dNFT Token in this project"
  dnfts: [DNFT!]! @derivedFrom(field: "project")

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Publish Record
type Publish @entity {
  "publishId"
  id: ID!
 
  "The account is publisher"
  publisher: Account!

  "The prepare publication data"
  publication: Publication!

  "The publish In hub"
  hub: Hub!

  "In the project"
  project: Project!

  "dNFT contract"
  derivativeNFT: DerivativeNFTContract!

  "The dNFT this publish is for"
  dnft: DNFT!

  "The new dNFT tokenId after publish"
  newTokenId: BigInt!

  "The amount of initially published"
  amount: BigInt!

  "collect module init data"
  collectModuleInitData: Bytes!

  "The date/time the event emit in seconds since Unix epoch"
  timestamp: BigInt!
}

# Airdrop history
type DnftAirdropedHistory @entity {
  id: ID!
  project: Project!
  publish: Publish!
  derivativeNFT: DerivativeNFTContract!
  from: Account!
  tokenId: BigInt!
  toAccounts: [BigInt!]!
  values: [BigInt!]!
  newTokenIds: [BigInt!]!
  timestamp: BigInt!
}

# Bank Contract Deposit event
type DepositHistory @entity {
  id: ID!
  sender: Bytes!
  amount: BigInt!
  receiver: Bytes!
  balance: BigInt!
  data: Bytes
  timestamp: BigInt!
}


type Transaction @entity {
  id: ID!
  owner: Bytes!
  txIndex: BigInt!
  to: Bytes
  value: BigInt
  data: Bytes
  isConfirmed: Boolean!
  timestamp: BigInt!
}

type ExecuteTransactionHistory @entity {
  id: ID!
  owner: Bytes!
  txIndex: BigInt!
  to: Bytes!
  value: BigInt!
  timestamp: BigInt!
}

type ExchangeVoucherHistory @entity {
  id: ID!
  soulBoundTokenId: BigInt!
  operator: Bytes!
  tokenId: BigInt!
  sbtValue: BigInt!
  timestamp: BigInt!
}

type ExecuteTransactionERC3525History @entity {
  id: ID!
  owner: Bytes!
  txIndex: BigInt!
  fromTokenId: BigInt!
  toTokenId: BigInt!
  value: BigInt!
  timestamp: BigInt!
}

# Voucher dNFT
type NFTVoucherHistory @entity {
  id: ID!
  soulBoundTokenId: BigInt!
  account: Account!
  vouchType: Int!
  tokenId: BigInt!
  sbtValue: BigInt!
  generateTimestamp: BigInt!
}

#  Voucher Asset
type VoucherAsset @entity {
  id: ID!
  wallet: Bytes!
  tokenId: BigInt!
  value: BigInt!
  timestamp: BigInt!
}

type VoucherRecord @entity {
  id: ID!
  vouchType: Int!
  tokenId: BigInt!
  etherValue: BigInt!
  sbtValue: BigInt!
  generateTimestamp: BigInt!
  endTimestamp: BigInt!
}

# ProfileCreator Whitelisted Record
type ProfileCreatorWhitelistedRecord @entity {
  id: ID!
  profileCreator: Bytes!
  whitelisted: Boolean!
  caller: Bytes!
  timestamp: BigInt!
}

# FeeCollectModule
type FeesForCollectHistory @entity {
  id: ID!
  publish: Publish!
  tokenId: BigInt!
  payValue: BigInt!
  owner: Account!
  collector: Account!
  genesisCreator: Account!
  previousCreator: Account!
  referrer: Account
  treasuryAmount: BigInt!
  genesisAmount: BigInt!
  previousAmount: BigInt!
  referrerAmount: BigInt
  adjustedAmount: BigInt!
  timestamp: BigInt!
}

# Receiver history
type ReceiverReceivedHistory @entity {
  id: ID!
  operator: Bytes!
  fromTokenId: BigInt!
  toTokenId: BigInt!
  value: BigInt!
  data: Bytes
  gas: BigInt!
  timestamp: BigInt!
}

# Dispatcher Set history
type Dispatcher @entity {
  id: ID!
  account: Account!
  dispatcher: Bytes!
  timestamp: BigInt!
}

# StateSet history
type StateSetHistory @entity {
  id: ID!
  caller: Bytes!
  prevState: Int!
  newState: Int!
  timestamp: BigInt!
}

# Bank treasury ERC3525Received history
type ERC3525ReceivedHistory @entity {
  id: ID!
  sender: Bytes!
  operator: Bytes!
  from: Account!
  to: Account!
  value: BigInt!
  data: Bytes!
  gas: BigInt!
  timestamp: BigInt!
}

# Manager contract EmergencyAdminSet history
type EmergencyAdminSetHistory @entity {
  id: ID!
  caller: Bytes!
  oldEmergencyAdmin: Bytes!
  newEmergencyAdmin: Bytes!
  timestamp: BigInt!
}

# Manager contract ManagerGovernanceSet history
type ManagerGovernanceSetHistory @entity {
  id: ID!
  caller: Bytes!
  prevGovernance: Bytes!
  newGovernance: Bytes!
  timestamp: BigInt!
}

# ModuleGlbals hub creator set whitelist 
type HubCreatorWhitelistedRecord  @entity {
  id: ID!
  soulBoundTokenId: BigInt!
  whitelisted: Boolean!
  timestamp: BigInt!
}

# ModuleGlbals Treasury Set history
type ModuleGlobalsTreasurySetHistory @entity {
  id: ID!
  prevTreasury: Bytes!
  newTreasury: Bytes!
  timestamp: BigInt!
}

# ModuleGlbals Voucher Set history
type ModuleGlobalsVoucherSetHistory @entity {
  id: ID!
  prevVoucher: Bytes!
  newVoucher: Bytes!
  timestamp: BigInt!
}

type UserAmountLimitSetHistory @entity {
  id: ID!
  preUserAmountLimit: BigInt!
  userAmountLimit: BigInt!
  timestamp: BigInt!
}

# ModuleGlbals Manager Set history
type ModuleGlobalsManagerSetHistory @entity {
  id: ID!
  prevManager: Bytes!
  newManager: Bytes!
  timestamp: BigInt!
}

# ModuleGlbals SBT Set history
type ModuleGlobalsSBTSetHistory @entity {
  id: ID!
  prevSBT: Bytes!
  newSBT: Bytes!
  timestamp: BigInt!
}

# ModuleGlbals Governance Set history
type ModuleGlobalsGovernanceSetHistory @entity {
  id: ID!
  prevGovernance: Bytes!
  newGovernance: Bytes!
  timestamp: BigInt!
}

# PublishRoyalty setting
type PublishRoyalty @entity {
  id: ID!
  publishRoyalty: BigInt!
}

# Treasury Fee Setting
type TreasuryFeeRecord @entity {
  id: ID!
  prevTreasuryFee: Int!
  newTreasuryFee: Int!
  timestamp: BigInt!
}

# ModuleGlbals PublishRoyalty Set record
type PublishRoyaltyRecord @entity {
  id: ID!
  prevPublishRoyalty: BigInt!
  newPublishRoyalty: BigInt!
  timestamp: BigInt!
}

# CollectModule Whitelisted record
type CollectModuleWhitelistedRecord @entity {
  id: ID!
  collectModule: Bytes!
  whitelisted: Boolean!
  timestamp: BigInt!
}

# PublishModule Whitelisted record
type PublishModuleWhitelistedRecord @entity {
  id: ID!
  publishModule: Bytes!
  whitelisted: Boolean!
  timestamp: BigInt!
}

# Template Whitelisted record
type TemplateWhitelistedRecord @entity {
  id: ID!
  template: Bytes!
  whitelisted: Boolean!
  timestamp: BigInt!
}

# Bank treasury ExchangeSBTByEth history
type ExchangeSBTByEthHistory @entity {
  id: ID!
  account: Account!
  exchangeWallet: Bytes!
  sbtValue: BigInt!
  timestamp: BigInt!
}

# Bank treasury ExchangeEthBySBTHistory history
type ExchangeEthBySBTHistory @entity {
  id: ID!
  account: Account!
  toWallet: Bytes!
  sbtValue: BigInt!
  exchangePrice: BigInt!
  ethAmount: BigInt!
  timestamp: BigInt!
}

# Market Place
type Market @entity {
  "DerivativeNFTAddress"
  id: ID!
  derivativeNFT: DerivativeNFTContract!
  project: Project! 
  feePayType: Int!
  feeShareType: Int!
  royaltyBasisPoints: Int!
  collectModule: Bytes!
  timestamp: BigInt!
}

type MarketPlaceERC3525ReceivedHistory @entity {
  id: ID!
  sender: Bytes!
  operator: Bytes!
  fromTokenId: BigInt!
  toTokenId: BigInt!
  value: BigInt!
  data: Bytes
  gas: BigInt!
  timestamp: BigInt!
}

type Creator @entity {
  "The account's address"
  id: ID!

  "The creator's account information"
  account: Account!

  "All dNFTs minted by this creator"
  nfts: [DNFT!]! @derivedFrom(field: "creator")

  "The total SBTValue for sales of dNFTs this creator minted"
  netSalesInSBTValue: BigDecimal!

  "The total SBTValue for sales of dNFTs this creator minted but still pending finalization"
  netSalesPendingInSBTValue: BigDecimal!

  "The total SBTValue earned by this creator"
  netRevenueInSBTValue: BigDecimal!

  "The total SBTValue earned by this creator but still pending finalization"
  netRevenuePendingInSBTValue: BigDecimal!
}

type DerivativeNFTContract @entity {
  "The contract's address"
  id: ID!

  "The contract address"
  contract: Bytes!

  "The token name"
  name: String

  "The token symbol"
  symbol: String

  "Append baseURI+tokenIPFSPath to get the tokenURI"
  baseURI: String

  "Max tokenId for the collection, if applicable"
  maxTokenID: BigInt

  "All dNFTs minted by this contract"
  nfts: [DNFT!]! @derivedFrom(field: "derivativeNFT")
}

type DnftMarketContract @entity {
  "The contract's address"
  id: ID!

  "How many bids have been placed for any auction on Foundation"
  numberOfBidsPlaced: BigInt!
}

enum DnftMarketAuctionStatus {
  "This auction has not been canceled or finalized yet, it may be active or pending finalization"
  Open

  "This auction was canceled before the reserve price was hit"
  Canceled

  "This auction was finalized and the dNFT has been transferred to the winner"
  Finalized

  "This auction was invalidated due to another action such as Buy Now"
  Invalidated
}

type DnftMarketAuction @entity {
  "marketContractAddress-auctionId"
  id: ID!

  "The contract managing this auction"
  dnftMarketContract: DnftMarketContract!

  "The id for this auction"
  auctionId: BigInt!

  "The dNFT being sold in this auction"
  dnft: DNFT!

  "The dNFT contract for this dNFT"
  derivativeNFT: DerivativeNFTContract!

  "The project for this dNFT"
  project: Project!

  "The current status of this auction"
  status: DnftMarketAuctionStatus!

  "The dNFT owner currently offering the dNFT for sale"
  seller: Account!

  "The date/time the auction was initially created in seconds since Unix epoch"
  dateCreated: BigInt!

  "The tx hash where this auction was initially created"
  transactionHashCreated: Bytes!

  "The date/time the auction countdown began, only known once reserve price has been met in seconds since Unix epoch"
  dateStarted: BigInt

  "The date/time the auction will be closed, only known once the reserve price has been met in seconds since Unix epoch"
  dateEnding: BigInt

  "The date/time the auction was canceled in seconds since Unix epoch, if applicable"
  dateCanceled: BigInt

  "The reason this auction was canceled, if known"
  canceledReason: String

  "The date/time the auction was finalized in seconds since Unix epoch, if applicable"
  dateFinalized: BigInt

  "The tx hash where this auction was canceled, if applicable"
  transactionHashCanceled: Bytes

  "The initial reserve price which needs to be met in order to begin the auction countdown"
  reservePriceInSBTValue: BigDecimal!

  "The first bid which met the reserve price"
  initialBid: DnftMarketBid

  "The current highest bid, if one has been placed"
  highestBid: DnftMarketBid

  "All bids placed in this auction"
  bids: [DnftMarketBid!]! @derivedFrom(field: "dnftMarketAuction")

  "How much the creator earned from this auction, set once there a bid is placed"
  creatorRevenueInSBTValue: BigDecimal

  "How much the previous creator earned from this auction, set once there a bid is placed"
  previousCreatorRevenueInSBTValue: BigDecimal

  "How much Foundation earned from this auction, set once there a bid is placed"
  foundationRevenueInSBTValue: BigDecimal

  "How much the owner (if not the creator) earned from this auction, set once there a bid is placed"
  ownerRevenueInSBTValue: BigDecimal

  "How long the auction runs for once the reserve price has been met in seconds"
  duration: BigInt!

  "How long to extend the dateEnding if a bid is placed near the end of the countdown in seconds"
  extensionDuration: BigInt!

  "True if this is the first sale on Foundation and being sold by the creator"
  isPrimarySale: Boolean!

  "How many bids have been placed for any auction on Foundation"
  numberOfBids: BigInt!

  "The volume of SBTValue bid"
  bidVolumeInSBTValue: BigDecimal!

  "The date/time the auction was invalidated in seconds since Unix epoch, if applicable"
  dateInvalidated: BigInt

  "The tx hash where this auction was invalidated, if applicable"
  transactionHashInvalidated: Bytes

  "Referrer address for the winner bid, if applicable"
  buyReferrer: Account

  "Referral fee paid for the winner bid, if applicable"
  buyReferrerFee: BigDecimal

  "Referral fee paid for the winner bid from owner fee, if applicable"
  buyReferrerSellerFee: BigDecimal

  "How much Foundation earned from this auction"
  foundationProtocolFeeInSBTValue: BigDecimal
}

enum DnftMarketBidStatus {
  "This bid is currently the highest, either on-track to win or has won and is pending finalization"
  Highest

  "This bid was outbid by another user"
  Outbid

  "This bid won the auction and was finalized, completing the dNFT transfer"
  FinalizedWinner
}

type DnftMarketBid @entity {
  "marketContractAddress-auctionId-txHash-logId"
  id: ID!

  "The auction this bid was for"
  dnftMarketAuction: DnftMarketAuction!

  "The dNFT being sold in this auction"
  dnft: DNFT!

  "The account which placed the bid"
  bidder: Account!

  "The date/time the bid was placed in seconds since Unix epoch"
  datePlaced: BigInt!

  "The tx hash that placed the bid"
  transactionHashPlaced: Bytes!

  "The size of the bid placed, including fees"
  amountInSBTValue: BigDecimal!

  "The current status of this bid"
  status: DnftMarketBidStatus!

  "The date/item when this bid became no longer Active in seconds since Unix epoch, if applicable"
  dateLeftActiveStatus: BigInt

  "The tx hash that moved this bid out of Active status, if applicable"
  transactionHashLeftActiveStatus: Bytes

  "The account which offered this dNFT for sale"
  seller: Account!

  "True if this bid caused the end time of an auction to be extended"
  extendedAuction: Boolean!

  "The bid which outbid this one, if applicable"
  outbidByBid: DnftMarketBid

  "The bid this one outbid, if applicable"
  bidThisOutbid: DnftMarketBid
}

enum Marketplace {
  "Foundation's market contract is the only one supported ATM but more will be added in the future"
  Foundation
}

enum HistoricalEvent {
  "The original mint event for this dNFT"
  Minted

  "The dNFT has been listed for sale"
  Listed

  "The dNFT was unlisted from the market"
  Unlisted

  "The price for this listing has been modified"
  PriceChanged

  "A bid for the dNFT has been made"
  Bid

  "The dNFT has been sold, this status is not reflected until the auction has been settled"
  Sold

  "The sale has been settled on-chain and the dNFT was transferred to the new owner"
  Settled

  "The dNFT was transferred from one address to another"
  Transferred

  "The dNFT value was transferred from one address to another"
  ValueTransferred

  "The dNFT was burned and now no longer available on-chain"
  Burned

  "The creator has been migrated to a new account"
  CreatorMigrated

  "The current owner of this dNFT has migrated to a new account"
  OwnerMigrated

  "The seller for the current auction has migrated to a new account"
  SellerMigrated

  "The payment address for this dNFT has migrated to a new address"
  CreatorPaymentAddressMigrated

  "The auction was invalidated due to another action such as Buy Now"
  AuctionInvalidated

  "The dNFT received an offer"
  OfferMade

  "The latest offer for an dNFT was increased"
  OfferChanged

  "The offer for this dNFT expired before it was expired, this status is not reflected until another action is performed"
  OfferExpired

  "The offer for this dNFT was accepted"
  OfferAccepted

  "The offer for this dNFT is no longer valid due to another action such as Buy Now"
  OfferInvalidated

  "The offer for this dNFT was canceled"
  OfferCanceled

  "The dNFT had a buy now price set"
  BuyPriceSet

  "The buy now for this dNFT was accepted"
  BuyPriceAccepted

  "The buy now for this dNFT is no longer valid due to another action such as auction kick off"
  BuyPriceInvalidated

  "The buy now for this dNFT was canceled"
  BuyPriceCanceled
}

type DnftHistory @entity {
  "tx-logId-eventType"
  id: ID!

  "The dNFT being sold in this auction"
  dnft: DNFT!

  "The type of action that this row represents"
  event: HistoricalEvent!

  "The related auction for this change, if applicable"
  auction: DnftMarketAuction

  "The related offer for this change, if applicable"
  offer: DnftMarketOffer

  "The related buy now for this change, if applicable"
  buyNow: DnftMarketBuyNow

  "The contract which processed this event, may be a marketplace or the dNFT itself"
  contractAddress: Bytes!

  "The date/time of this event in seconds since Unix epoch"
  date: BigInt!

  "Which market which facilitated this transaction, null when the action was specific to the dNFT itself"
  marketplace: Marketplace

  "The transaction hash where this event occurred"
  transactionHash: Bytes!

  "The account associated with this event, if unknown the txOrigin is used. Usually the same as txOrigin but may differ when multisig or other contracts are used"
  actorAccount: Account!

  "The msg.sender for the transaction associated with this event"
  txOrigin: Account!

  "The destination of the dNFT for events where the dNFT was transferred, null if n/a"
  nftRecipient: Account

  "The value amount associated with this event, in SBTValue. Null if unknown or n/a"
  amountInSBTValue: BigDecimal

  "The ERC-20 value associated with this event. Null if unknown or SBTValue was used"
  amountInTokens: BigInt

  "The ERC-20 token address associated with this event. Null if unknown or SBTValue was used"
  tokenAddress: Bytes
}

type PercentSplitShare @entity {
  "contractAddress-logId"
  id: ID!

  "The split this share is for"
  split: PercentSplit!

  "The recipient included in the split"
  account: Account!

  "The percent share this recipient will receive"
  shareInPercent: BigDecimal!

  "The index position of this share in the split, as defined in the contract"
  indexOfShare: BigInt!
}

# LEVEL_FIVE only
type PercentSplit @entity {
  "The address of this split contract"
  id: ID!

  "The recipients and their percent share for this split"
  shares: [PercentSplitShare!]! @derivedFrom(field: "split")

  "All the dNFTs currently leveraging this split"
  nfts: [DNFT!]! @derivedFrom(field: "percentSplit")

  "How many different shares are in this split"
  shareCount: BigInt!

  "The date/time this split was initially created in seconds since Unix epoch"
  dateCreated: BigInt!
}

type Fsbt @entity {
  "userAddress"
  id: ID!
  user: Account!
  balanceInSBTValue: BigDecimal!
  escrow: [FsbtEscrow!]! @derivedFrom(field: "fsbt")
  dateLastUpdated: BigInt!
}

type FsbtEscrow @entity {
  "userAddress-dateExpiry"
  id: ID!
  fsbt: Fsbt!
  amountInSBTValue: BigDecimal!
  dateExpiry: BigInt!
  transactionHashCreated: Bytes!
  transactionHashRemoved: Bytes
  dateRemoved: BigInt
}

enum DnftMarketOfferStatus {
  "This offer is applicable unless it has expired"
  Open

  "This offer has been outbid by another offer, potentially from the same buyer"
  Outbid

  "This offer has expired, this status is not reflected until another action is performed"
  Expired
  
  "This offer has been canceled"
  Canceled

  "This offer was accepted"
  Accepted

  "This offer is no longer valid due to another action such as Buy Now"
  Invalidated
}

type DnftMarketOffer @entity {
  "tx-logId"
  id: ID!

  "The contract managing this offer"
  dnftMarketContract: DnftMarketContract!

  "The dNFT this offer is for"
  dnft: DNFT!

  "The dNFT contract for this dNFT"
  derivativeNFT: DerivativeNFTContract!

  "The current status of this offer"
  status: DnftMarketOfferStatus!

  "The account making this offer"
  buyer: Account!

  "The seller which accepted this offer, if applicable"
  seller: Account

  "The value being offered for this dNFT"
  amountInSBTValue: BigDecimal!

  "The date/time the offer was initially created in seconds since Unix epoch"
  dateCreated: BigInt!

  "The tx hash where this offer was initially created"
  transactionHashCreated: Bytes!

  "The date/time the offer will expire in seconds since Unix epoch"
  dateExpires: BigInt!

  "The date/time the offer was canceled in seconds since Unix epoch, if applicable"
  dateCanceled: BigInt

  "The reason this offer was canceled, if known"
  canceledReason: String

  "The tx hash where this offer was canceled, if applicable"
  transactionHashCanceled: Bytes

  "The date/time the offer was accepted in seconds since Unix epoch, if applicable"
  dateAccepted: BigInt

  "The tx hash where this offer was accepted, if applicable"
  transactionHashAccepted: Bytes

  "The date/time the offer was outbid in seconds since Unix epoch, if applicable"
  dateOutbid: BigInt

  "The tx hash where this offer was outbid, if applicable"
  transactionHashOutbid: Bytes

  "The date/time the offer was invalidate in seconds since Unix epoch, if applicable"
  dateInvalidated: BigInt

  "The tx hash where this offer was outbid, if applicable"
  transactionHashInvalidated: Bytes

  "How much the creator earned from this offer, set once accepted"
  creatorRevenueInSBTValue: BigDecimal

  "How much the previous creator earned from this auction, set once there a bid is placed"
  previousCreatorRevenueInSBTValue: BigDecimal

  "How much Protocol earned from this offer, set once accepted"
  foundationRevenueInSBTValue: BigDecimal

  "How much the owner (if not the creator) earned from this offer, set once accepted"
  ownerRevenueInSBTValue: BigDecimal

  "True if this is the first sale on Foundation and being sold by the creator, not known until the offer is accepted"
  isPrimarySale: Boolean

  "The offer that was outbid when this offer was placed, if applicable"
  outbidOffer: DnftMarketOffer

  "The offer that outbid this offer, if applicable"
  offerOutbidBy: DnftMarketOffer

  "Referrer address for the accepted offer, if applicable"
  buyReferrer: Account

  "Referral fee paid for the accepted offer, if applicable"
  buyReferrerFee: BigDecimal

  "Referral fee paid for the accepted offer from owner fee, if applicable"
  buyReferrerSellerFee: BigDecimal

  "How much Foundation earned from this offer, set once accepted"
  foundationProtocolFeeInSBTValue: BigDecimal
}

enum DnftMarketBuyNowStatus {
  "This buy now is applicable"
  Open

  "This buy now has been canceled"
  Canceled

  "This buy now was accepted"
  Accepted

  "This buy now is no longer valid due to another action such as accepted offer / kicked off auction"
  Invalidated
}

type DnftMarketBuyNow @entity {
  "tx-logId"
  id: ID!

  "The contract managing this buy now"
  dnftMarketContract: DnftMarketContract!

  "The dNFT this buy now is for"
  dnft: DNFT!

  "The dNFT contract for this dNFT"
  derivativeNFT: DerivativeNFTContract!

  "The Project of this buy now if for"
  project: Project!

  "The current status of this buy now"
  status: DnftMarketBuyNowStatus!

  "The seller which owns the dNFT."
  seller: Account!

  "The value being bought at for this dNFT"
  amountInSBTValue: BigDecimal!

  "The units put on sell for this dNFT"
  tokenIdEscrow: BigInt!

  "The units put on sell for this dNFT"
  onSellUnits: BigInt!

  "The units put on sell for this dNFT"
  seledUnits: BigInt!

  "The date/time the buy now was initially created in seconds since Unix epoch"
  dateCreated: BigInt!

  "The tx hash where this buy now was initially created"
  transactionHashCreated: Bytes!

  "The dnft recipient, if applicable"
  buyer: Account

  "The date/time the buy now was canceled in seconds since Unix epoch, if applicable"
  dateCanceled: BigInt

  "The tx hash where this buy now was canceled, if applicable"
  transactionHashCanceled: Bytes

  "The date/time the buy now was accepted in seconds since Unix epoch, if applicable"
  dateAccepted: BigInt

  "The tx hash where this buy now was accepted, if applicable"
  transactionHashAccepted: Bytes

  "The date/time the buy now was invalidate in seconds since Unix epoch, if applicable"
  dateInvalidated: BigInt

  "The tx hash where this offer was outbid, if applicable"
  transactionHashInvalidated: Bytes

  "How much the creator earned from this buy now, set once accepted"
  creatorRevenueInSBTValue: BigDecimal

  "How much the previous creator earned from this auction, set once there a bid is placed"
  previousCreatorRevenueInSBTValue: BigDecimal

  "How much Protocol earned from this buy now, set once accepted"
  foundationRevenueInSBTValue: BigDecimal

  "How much the owner (if not the creator) earned from this buy now, set once accepted"
  ownerRevenueInSBTValue: BigDecimal

  "True if this is the first sale on Foundation and being sold by the creator, not known until the offer is accepted"
  isPrimarySale: Boolean

  "Referrer address for the buy, if applicable"
  buyReferrer: Account

  "Referral fee paid for the buy, if applicable"
  buyReferrerFee: BigDecimal

  "Referral fee paid for the buy from owner fee, if applicable"
  buyReferrerSellerFee: BigDecimal

  "How much Foundation earned from this buy now, set once accepted"
  foundationProtocolFeeInSBTValue: BigDecimal
}

### DNFT ###

type DNFT @entity {
  "tokenContractAddress-tokenId"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  "The tokenId for this specific dNFT"
  tokenId: BigInt!

  "The project of this dNFT"
  project: Project!

  "The publish of this dNFT"
  publish: Publish!
 
  "Link to dNFT ImageURI"
  imageURI: DnftImageURI

  "The content path for the metadata of this dNFT on IPFS"
  tokenIPFSPath: String

  "The creator of this dNFT"
  creator: Creator

  "The date/time when this dNFT was minted in seconds since Unix epoch"
  dateMinted: BigInt!

  "The transfer details where this dNFT was minted"
  mintedTransfer: DnftTransfer

  "The current owner of this dNFT"
  owner: Account!

  "The current owner or the owner who listed the dNFT"
  ownedOrListedBy: Account!

  "An account authorized to transfer this dNFT, if one was approved"
  approvedSpender: Account

  "All dNFT collection that have collected for this dNFT"
  dnftCollections: [DnftCollection!] @derivedFrom(field: "dnft")

  "All transfers that have occurred for this dNFT"
  transfers: [DnftTransfer!] @derivedFrom(field: "dnft")

  "All transferValues that have occurred for this dNFT"
  transferValues: [DnftTransferValue!] @derivedFrom(field: "dnft")

  "All bids ever placed for this dNFT"
  bids: [DnftMarketBid!]! @derivedFrom(field: "dnft")

  "All history ever collected for this dNFT"
  collectedHistories: [DnftCollectedHistory!]! @derivedFrom(field: "dnft")

  "The total SBTValue for sales of this dNFT"
  netSalesInSBTValue: BigDecimal!

  "The total SBTValue for sales of this dNFT but still pending finalization"
  netSalesPendingInSBTValue: BigDecimal!

  "The total SBTValue earned by the creator from this dNFT"
  netRevenueInSBTValue: BigDecimal!

  "The total SBTValue earned by this creator from this dNFT but still pending finalization"
  netRevenuePendingInSBTValue: BigDecimal!

  "True if the dNFT has not yet been sold in the Foundation market"
  isFirstSale: Boolean!

  "All auctions which were created for this dNFT"
  auctions: [DnftMarketAuction!]! @derivedFrom(field: "dnft")

  "The current or last previous auction for this dNFT"
  mostRecentAuction: DnftMarketAuction

  "The current or last auction for this dNFT which has not been canceled, if any"
  mostRecentActiveAuction: DnftMarketAuction

  "The last auction for this dNFT which was finalized, if there was one"
  latestFinalizedAuction: DnftMarketAuction

  "The event history for this dNFT"
  dnftHistory: [DnftHistory!]! @derivedFrom(field: "dnft")

  "An optional address to receive revenue and creator royalty payments generated by this dNFT"
  tokenCreatorPaymentAddress: Bytes

  "A reference to the split details defined by the tokenCreatorPaymentAddress, if that address is a PercentSplit"
  percentSplit: PercentSplit

  "The most recent sale price in the Foundation marketplace, if there has been one"
  lastSalePriceInSBTValue: BigDecimal

  "All offers made for this dNFT"
  nftOffers: [DnftMarketOffer!]! @derivedFrom(field: "dnft")

  "The most recent offer made for this dNFT, which may or may not still be valid"
  mostRecentOffer: DnftMarketOffer

  "The most recent buy now for this dNFT, which may or may not still be valid"
  mostRecentBuyNow: DnftMarketBuyNow

  "All buy nows made for this dNFT"
  nftBuyNows: [DnftMarketBuyNow!]! @derivedFrom(field: "dnft")
}

type DnftTransfer @entity {
  "tx-logId"
  id: ID!

  "The DNFT which was transferred"
  dnft: DNFT!

  "The source of the transfer, 0 when the token was minted"
  from: Account!

  "The destination of the transfer, 0 when the token is burned"
  to: Account!

  tokenId: BigInt!

  "The date/time of the transfer in seconds since Unix epoch"
  dateTransferred: BigInt!

  "The tx hash where the transfer occurred"
  transactionHash: Bytes!

}

# DNFT Collected history
type DnftCollectedHistory @entity {
  "tokenContractAddress-projectId-tokenId"
  id: ID!
  project: Project!
  derivativeNFT: DerivativeNFTContract!

  "The dNFT this publish is for"
  dnft: DNFT!

  from: Account!
  to: Account!
  tokenId: BigInt!
  units: BigInt!
  newTokenId: BigInt!
  timestamp: BigInt!
}

#  DNFT collection
type DnftCollection @entity {
  "tokenContractAddress-tokenId"
  id: ID!

  "The DNFT for this token"
  dnft: DNFT!

  "The current owner of this dNFT"
  owner: Account!

  tokenId: BigInt!

  value: BigInt!

  timestamp: BigInt!
}


#  DNFT transfer value history    
type DnftTransferValue @entity {
  "tokenAddress-fromTokenId-toTokenId"
  id: ID!

  "The DNFT which was transferred"
  dnft: DNFT!

  from: Account!

  to: Account!

  value: BigInt!

  timestamp: BigInt!
} 

#  DNFT Slot Changed history    
type DnftSlotChanged @entity {
  "tokenAddress-tokenId-oldSlot"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  tokenId: BigInt!

  oldSlot: BigInt!

  newSlot: BigInt!

  timestamp: BigInt!
} 

# DNFT burn history    
type DnftBurn @entity {
  "tokenAddress-tokenId"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  project: Project!

  tokenId: BigInt!

  owner: Account!

  timestamp: BigInt!
}    


# DNFT account ApprovalForAll 
type DnftAccountApproval @entity {
  "tokenAddress-owner-spender"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  "The account which granted this approval"
  owner: Account!

  "The account which is authorized to transfer dNFTs held by the owner"
  spender: Account!
}

# DNFT ApprovalValue 
type DnftApprovalValue @entity {
  "tokenAddress-owner-spender"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  "The account which granted this approval"
  owner: Account!

  tokenId: BigInt!

  operator: Account!

  value: BigInt!
  
  timestamp: BigInt!
}    

#  DNFT image uri  
type DnftImageURI @entity {
  "tokenAddress-tokenId"
  id: ID!

  "The token's contract"
  derivativeNFT: DerivativeNFTContract!

  tokenId: BigInt!

  imageURI: String!

  timestamp: BigInt!
}